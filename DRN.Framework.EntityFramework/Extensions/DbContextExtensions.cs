using DRN.Framework.EntityFramework.Context;
using DRN.Framework.EntityFramework.Context.Interceptors;
using DRN.Framework.SharedKernel.Domain;
using DRN.Framework.Utils.Extensions;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;
using Npgsql;

namespace DRN.Framework.EntityFramework.Extensions;

internal static class DbContextExtensions
{
    public static void ModelCreatingDefaults(this DbContext dbContext, ModelBuilder modelBuilder)
    {
        var context = dbContext.GetType();
        modelBuilder.HasDefaultSchema(context.Name.ToSnakeCase())
            .ApplyConfigurationsFromAssembly(context.Assembly, type => type.Namespace!.Contains(context.Namespace!))
            .Ignore<DomainEvent>()
            .Ignore<IDomainEvent>();

        var baseEntityType = typeof(SourceKnownEntity);
        var iEntityWithModelType = typeof(IEntityWithModel<>);
        var entities = modelBuilder.Model.GetEntityTypes()
            .Where(type => baseEntityType.IsAssignableFrom(type.ClrType) && type.ClrType != baseEntityType) // Exclude base class itself
            .Select(e => new EntityTypeBuilderPair(e.ClrType, modelBuilder.Entity(e.ClrType)));
        //todo: add table per hierarchy and table per concrete type tests
        foreach (var (entityType, entityTypeBuilder) in entities)
        {
            // Autoconfigure common properties 
            entityTypeBuilder.HasKey(nameof(SourceKnownEntity.Id));
            entityTypeBuilder.Property(nameof(SourceKnownEntity.Id)) //value will be generated by SourceKnownIdGenerator
                .ValueGeneratedNever()
                .IsRequired();
            entityTypeBuilder.Property(nameof(SourceKnownEntity.Id))
                .ValueGeneratedNever()
                .HasValueGenerator<SourceKnownIdValueGenerator>();

            entityTypeBuilder.Ignore(nameof(SourceKnownEntity.EntityId)); //runtime generated values by using source known id and entity type id
            entityTypeBuilder.Ignore(nameof(SourceKnownEntity.EntityIdSource));

            entityTypeBuilder.Property(nameof(SourceKnownEntity.ExtendedProperties))
                .HasColumnType("jsonb")
                .HasDefaultValueSql("'{}'::jsonb")
                .ValueGeneratedOnAdd()
                .IsRequired();

            var implementsModel = entityType.GetInterfaces().Any(i => i.IsGenericType && i.GetGenericTypeDefinition() == iEntityWithModelType);
            if (!implementsModel)
                continue;

            var property = entityType.GetProperty(nameof(SourceKnownEntity<object>.Model), BindingFlag.InstancePublic);
            if (property == null)
                continue;

            var ownedType = property.PropertyType;
            var ownedTypeName = nameof(SourceKnownEntity<object>.Model);

            entityTypeBuilder.OwnsOne(ownedType, ownedTypeName, builder => builder.ToJson());

            //todo evaluate soft delete
        }
    }

    public static TContext CreateDbContext<TContext>(this string[] args) where TContext : DbContext
    {
        var connectionString = args.FirstOrDefault()!;
        var optionsBuilder = string.IsNullOrWhiteSpace(connectionString)
            ? DbContextConventions.UpdateDbContextOptionsBuilder<TContext>()
            : DbContextConventions.UpdateDbContextOptionsBuilder<TContext>(
                new NpgsqlDataSourceBuilder(connectionString).Build());

        return (TContext)Activator.CreateInstance(typeof(TContext), optionsBuilder.Options)!;
    }

    public record EntityTypeBuilderPair(Type EntityType, EntityTypeBuilder EntityTypeBuilder);
}